# -*- coding: utf-8 -*-
"""
/***************************************************************************
AGLgisDialog
A QGIS plugin
Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
-------------------
begin                : 2024-10-24
git sha              : $Format:%H$
copyright            : (C) 2024 by Caio Arantes
email                : caiosimplicioarante@gmail.com
***************************************************************************/

/***************************************************************************
*                                                                         *
*   This program is free software; you can redistribute it and/or modify  *
*   it under the terms of the GNU General Public License as published by  *
*   the Free Software Foundation; either version 2 of the License, or     *
*   (at your option) any later version.                                   *
*                                                                         *
***************************************************************************/
"""

import os
import tempfile
import datetime
import requests
import re
import sys
import importlib
import platform
import subprocess
import traceback
import zipfile
import json
import webbrowser
import io
import array
import qgis
import pandas as pd
import numpy as np
import geopandas as gpd
import processing
import plotly.express as px
import plotly.graph_objects as go
import urllib.request
import ee

from functools import partial
from datetime import timedelta
from dateutil.relativedelta import relativedelta
from shapely.geometry import shape
from scipy.signal import savgol_filter
from osgeo import gdal

from qgis.core import (
    QgsMessageLog,
    Qgis,
    QgsWkbTypes,
    QgsVectorLayer,
    QgsVectorFileWriter,
    QgsFeatureRequest,
    QgsProject,
    QgsRasterLayer,
    QgsRasterShader,
    QgsColorRampShader,
    QgsSingleBandPseudoColorRenderer,
    QgsStyle,
    QgsRasterBandStats,
    QgsMapLayer,
    QgsColorRamp,
    QgsLayerTreeLayer,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsMultiBandColorRenderer,
    QgsContrastEnhancement,
    QgsProcessingFeedback,
    QgsApplication,
    QgsRectangle,
    QgsFeature,
    QgsGeometry,
    QgsField,
)
from qgis.PyQt.QtGui import QFont, QColor
from qgis.PyQt.QtCore import QDate, Qt, QVariant, QSettings, QTimer, QEvent
from qgis.PyQt.QtWidgets import (
    QApplication,
    QMainWindow,
    QLabel,
    QMessageBox,
    QFileDialog,
    QGridLayout,
    QWidget,
    QDialog,
    QVBoxLayout,
    QCheckBox,
    QDialogButtonBox,
    QDateEdit,
    QScrollArea,
    QPushButton,
    QHBoxLayout,
    QToolButton,
    QTextBrowser,
    QSizePolicy,
)


from qgis.PyQt import uic, QtWidgets
from qgis.PyQt.QtCore import Qt, QEvent # This specific import was duplicated multiple times, consolidating here.
from qgis.gui import (
    QgsMapToolEmitPoint,
    QgsRubberBand,
    QgsMapToolCapture,
    QgsMapToolExtent,
    QgsMapToolPan,
)
from qgis.utils import iface

from .modules import (
    map_tools,
    save_utils,
    authentication,
)


# =============================================================================
# AGLgisDialog Class Definition / Definição da Classe AGLgisDialog
# =============================================================================

# Load the .ui file based on the language setting / Carrega o arquivo .ui com
# base na configuração de idioma
ui_file = os.path.join("ui", "aglgis_dialog_base.ui")

FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), ui_file))

class AGLgisDialog(QDialog, FORM_CLASS):
    def __init__(self, parent=None, iface=None):
        super(AGLgisDialog, self).__init__(parent)
        self.setupUi(self)
        self.iface = iface
        
        self.setWindowFlags(
            Qt.WindowType.Window |
            Qt.WindowType.WindowCloseButtonHint |
            Qt.WindowType.WindowMinimizeButtonHint |
            Qt.WindowType.WindowMaximizeButtonHint
        )
        
        self.setModal(False)
        
        # Initialize timer but don't start it yet
        self.focus_timer = QTimer()
        self.focus_timer.timeout.connect(self.check_focus)

        authentication.loadProjectId(self)

        self.inicialize_variables()

        # UI setup and signal connections / Configuração da UI e conexões de sinal
        self.setup_ui()
        self.connect_signals()

        
        # Set default values / Define valores padrão
        self.last_clicked(3)
        self.load_intro()
       
        self.tabWidget.setCurrentIndex(0)
        
        # Lock window size immediately after initialization
        # Use QTimer to ensure the window is fully initialized
        QTimer.singleShot(0, lambda: self.resizeEvent("small"))

    def load_intro(self):
        # Always load English intro.html
        intro_path = os.path.join(os.path.dirname(__file__), "ui", "intro.html")
        with open(intro_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        self.QTextBrowser.setHtml(html_content)

    def showEvent(self, event):
        """Start timer when dialog is shown"""
        super().showEvent(event)
        
        # Ensure window is locked when first shown
        if not hasattr(self, '_size_locked'):
            self.resizeEvent("small")
            self._size_locked = True
            
        if hasattr(self, 'focus_timer'):
            self.focus_timer.start(100)

    def hideEvent(self, event):
        """Stop timer when dialog is hidden"""
        super().hideEvent(event)
        if hasattr(self, 'focus_timer'):
            try:
                self.focus_timer.stop()
            except RuntimeError:
                pass

    def check_focus(self):
        """Check if we should bring the plugin to front - less aggressive"""
        if not self.isVisible() or self.isMinimized():
            return
            
        # Only act if clicking on map canvas specifically
        active_window = QApplication.activeWindow()
        if (active_window == self.iface.mainWindow() and 
            not QApplication.activeModalWidget() and
            not self.isActiveWindow()):
            
            # Only raise, don't activate to avoid interfering with internal events
            self.raise_()

    def closeEvent(self, event):
        """Handle close event"""
        if hasattr(self, 'focus_timer'):
            try:
                self.focus_timer.stop()
            except RuntimeError:
                pass
        
        # Hide instead of close to preserve state
        self.hide()
        event.ignore()


    def inicialize_variables(self):
        """Initializes variables."""          

        # Initialize variables / Inicializa variáveis
        self.plot1 = None
        self.autentication = False
        self.folder_set = False
        self.inicio = None
        self.final = None
        self.nuvem = None
        self.vector_path = None
        self.aoi = None
        self.aoi_ckecked = False
        self.df = None
        self.recorte_datas = None
        self.df_aux = None
        self.selected_dates = []
        self.output_folder = None
        self.selected_aio_layer_path = None


    def setup_ui(self):
          # Prevent manual resizing
        """Initial UI setup."""
        """Configuração inicial da UI."""
        self.QTextBrowser.setReadOnly(True)  # Prevent editing / Impede a edição
        self.QTextBrowser.setTextInteractionFlags(Qt.TextInteractionFlag.TextBrowserInteraction)

        self.project_QgsPasswordLineEdit.setEchoMode(QtWidgets.QLineEdit.EchoMode.Normal)

        vegetation_index = [
            "VV",
            "VH",
            
        ]

        self.imagem_unica_indice.addItems(vegetation_index)
        
        self.combo_year.addItems(
            [str(year) for year in range(2017, datetime.datetime.now().year + 1)]
        )


    def connect_signals(self):
        """Connect UI signals to their respective slots."""
        """Conecta os sinais da UI aos seus respectivos slots."""
        

        self.autenticacao.clicked.connect(lambda: authentication.auth(self))
        self.desautenticacao.clicked.connect(lambda: authentication.auth_clear(self))
        
        # Connect the textChanged signal to the autoSaveProjectId function
        self.project_QgsPasswordLineEdit.textChanged.connect(
            lambda new_text: authentication.autoSaveProjectId(self, new_text)
        )



        self.update_vector.clicked.connect(self.update_vector_clicked)
        self.update_vector_2.clicked.connect(self.update_vector_clicked)
        self.tabWidget.currentChanged.connect(self.on_tab_changed)
        self.load_1index.clicked.connect(self.load_index)
        self.load_1index_preview.clicked.connect(lambda: self.load_index(True))
        self.hybrid.clicked.connect(map_tools.hybrid_function)
        self.QPushButton_next.clicked.connect(self.next_clicked)
        self.QPushButton_next_2.clicked.connect(self.next_clicked)
        self.QPushButton_next_4.clicked.connect(self.next_clicked)
        self.QPushButton_next_6.clicked.connect(self.next_clicked)
        self.QPushButton_back.clicked.connect(self.back_clicked)
        self.QPushButton_back_2.clicked.connect(self.back_clicked)
        self.QPushButton_back_4.clicked.connect(self.back_clicked)
        self.QPushButton_back_6.clicked.connect(self.back_clicked)
        self.QPushButton_back_7.clicked.connect(self.back_clicked)
        self.loadtimeseries.clicked.connect(self.loadtimeseries_clicked)
        self.navegador.clicked.connect(self.open_browser)
        self.datasrecorte.clicked.connect(self.datasrecorte_clicked)
        self.QPushButton_skip.clicked.connect(lambda: self.tabWidget.setCurrentIndex(5))

        self.salvar.clicked.connect(self.salvar_clicked)
        self.drawing.stateChanged.connect(self.drawing_clicked)

        self.vector_layer_combobox.currentIndexChanged.connect(self.get_selected_layer_path)

        self.vector_layer_combobox_2.currentIndexChanged.connect(self.combobox_2_update)

        self.mQgsFileWidget.fileChanged.connect(self.on_file_changed)
        self.radioButton_all.clicked.connect(self.all_clicked)
        self.radioButton_3months.clicked.connect(lambda: self.last_clicked(3))
        self.radioButton_6months.clicked.connect(lambda: self.last_clicked(6))
        self.radioButton_12months.clicked.connect(lambda: self.last_clicked(12))
        self.radioButton_3years.clicked.connect(lambda: self.last_clicked(3 * 12))
        self.radioButton_5years.clicked.connect(lambda: self.last_clicked(5 * 12))
        self.combo_year.currentIndexChanged.connect(self.selected_year_clicked)


        self.horizontalSlider_buffer.valueChanged.connect(self.update_labels)
        self.horizontalSlider_buffer_2.valueChanged.connect(self.update_labels_2)

        self.incioedit.dateChanged.connect(self.reload_update)

        self.finaledit.dateChanged.connect(self.reload_update)


    def load_index(self, preview=False):
        print("Loading index...")

    def combobox_2_update(self):
        print("combobox_2_update called")
        self.vector_layer_combobox.setCurrentIndex(
            self.vector_layer_combobox_2.currentIndex()
        )

    def reload_update(self):
        self.finaledit_2.setDate(self.finaledit.date())
        self.incioedit_2.setDate(self.incioedit.date())

    def update_labels(self):
        """Updates the text of several labels based on the values of horizontal
        sliders."""
        """Atualiza o texto de vários rótulos com base nos valores dos
        sliders horizontais."""

        self.label_buffer.setText(f"{self.horizontalSlider_buffer.value()}m")
        self.label_buffer_2.setText(f"{self.horizontalSlider_buffer.value()}m")
        self.horizontalSlider_buffer_2.setValue(self.horizontalSlider_buffer.value())

    def update_labels_2(self):
        """Updates the text of several labels based on the values of horizontal
        sliders."""
        """Atualiza o texto de vários rótulos com base nos valores dos
        sliders horizontais."""

        self.label_buffer.setText(f"{self.horizontalSlider_buffer_2.value()}m")
        self.label_buffer_2.setText(f"{self.horizontalSlider_buffer_2.value()}m")
        self.horizontalSlider_buffer.setValue(self.horizontalSlider_buffer_2.value())


    def open_link(self, url):
        """Open the clicked link in the default web browser."""
        """Abre o link clicado no navegador padrão."""
        print(f"Opening URL: {url.toString()}")
        webbrowser.open(url.toString())

    def last_clicked(self, months):
        today = datetime.datetime.today().strftime("%Y-%m-%d")
        one_month_ago = (datetime.datetime.today() - relativedelta(months=months)).strftime(
            "%Y-%m-%d"
        )
        self.finaledit.setDate(QDate.fromString(today, "yyyy-MM-dd"))
        self.incioedit.setDate(QDate.fromString(one_month_ago, "yyyy-MM-dd"))

    def all_clicked(self):
        today = datetime.datetime.today().strftime("%Y-%m-%d")
        since = "2017-03-28"
        self.finaledit.setDate(QDate.fromString(today, "yyyy-MM-dd"))
        self.incioedit.setDate(QDate.fromString(since, "yyyy-MM-dd"))

    def selected_year_clicked(self):
        """Sets the date range in the UI to the selected year from the combo
        box."""
        """Define o intervalo de datas na UI para o ano selecionado na combo
        box."""
        year = self.combo_year.currentText()
        start = f"{year}-01-01"
        end = f"{year}-12-31"
        self.incioedit.setDate(QDate.fromString(start, "yyyy-MM-dd"))
        self.finaledit.setDate(QDate.fromString(end, "yyyy-MM-dd"))

    def drawing_clicked(self):
        print("Drawing clicked")
        if self.drawing.isChecked():
            self.vector_builder()
        else:
            # Deactivate the extent tool if the checkbox is unchecked
            iface.mapCanvas().setMapTool(QgsMapToolPan(iface.mapCanvas()))

    def vector_builder(self):
        """Handles the event when the "Build Vector Layer" button is clicked."""
        if self.output_folder is None:
            self.pop_warning("Please select an output folder first.")
            return



        # Activate the extent drawing tool
        self.extent_tool = QgsMapToolExtent(iface.mapCanvas())
        self.extent_tool.extentChanged.connect(self.process_extent)
        iface.mapCanvas().setMapTool(self.extent_tool)
        print("Extent tool activated.")

    def process_extent(self, extent: QgsRectangle):
        """Process the drawn extent and save it as a vector layer."""
        # Transform the extent to EPSG:4326
        canvas_crs = iface.mapCanvas().mapSettings().destinationCrs()
        target_crs = QgsCoordinateReferenceSystem("EPSG:4326")
        transform = QgsCoordinateTransform(canvas_crs, target_crs, QgsProject.instance())
        extent_4326 = transform.transformBoundingBox(extent)

        # Create a vector layer in EPSG:4326
        layer = QgsVectorLayer("Polygon?crs=EPSG:4326", "drawn_extent", "memory")
        pr = layer.dataProvider()

        # Add fields
        pr.addAttributes([QgsField("id", QVariant.Int)])
        layer.updateFields()

        # Create a feature with the transformed extent
        feature = QgsFeature()
        geometry = QgsGeometry.fromRect(extent_4326)
        feature.setGeometry(geometry)
        feature.setAttributes([1])
        pr.addFeature(feature)

        # Update layer extents
        layer.updateExtents()

        # Generate unique filename and layer name with subdirectory
        shp_path, shp_name = self.get_subdirectory_filename("drawn_extent")
        print(f"Shapefile path: {shp_path}")
        print(f"Shapefile name: {shp_name}")

        # Write the layer to disk
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"

        QgsVectorFileWriter.writeAsVectorFormat(
            layer, shp_path, save_options
        )

        # Load the shapefile
        loaded_layer = QgsVectorLayer(shp_path, shp_name, "ogr")
        if loaded_layer.isValid():
            # Verify CRS
            if loaded_layer.crs().authid() != "EPSG:4326":
                print("Warning: Layer CRS is not EPSG:4326, reprojecting...")
                # Reproject if necessary
                params = {
                    'INPUT': loaded_layer,
                    'TARGET_CRS': target_crs,
                    'OUTPUT': 'memory:'
                }
                reprojected = processing.run("native:reprojectlayer", params)['OUTPUT']
                loaded_layer = reprojected

            QgsProject.instance().addMapLayer(loaded_layer)
            print(f"Layer added successfully with CRS: {loaded_layer.crs().authid()}")
            self.load_vector_layers()
            self.get_selected_layer_path()
            self.load_vector_function()
            self.find_area()

    def salvar_clicked(self):
        """Handles the event when the save button is clicked."""
        """Manipula o evento quando o botão salvar é clicado."""
        df = self.df_aux
        try:
            df = df[["date", "AOI_average", "savitzky_golay_filtered", "image_id"]]
        except:
            df = df[["date", "AOI_average", "image_id"]]

        name = (
            f"time_series.csv"
        )
        save_utils.save(df, name, self)

    def datasrecorte_clicked(self):
        """Opens a dialog for selecting specific dates for the time series."""
        """Abre um diálogo para selecionar datas específicas para a série
        temporal."""
        dialog = QDialog(self)
        dialog.setWindowTitle("Date Selection for Time Series")
        dialog.setGeometry(100, 100, 400, 500)

        layout = QVBoxLayout(dialog)

        # Scroll Area for Checkboxes / Área de Scroll para Checkboxes
        scroll_area = QScrollArea(dialog)
        scroll_area.setWidgetResizable(True)
        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)

        self.checkboxes = []
        self.group_checkboxes = {}  # Store month group checkboxes
        self.year_checkboxes = {}  # Store year checkboxes
        self.group_widgets = {}  # Store month group content widgets

        # Group Dates by Year and Month / Agrupa Datas por Ano e Mês
        self.df["date"] = pd.to_datetime(
            self.df["date"]
        )  # Ensure dates are datetime objects
        grouped = self.df.groupby([self.df["date"].dt.year, self.df["date"].dt.month])

        # Organize by Year / Organiza por Ano
        years = self.df["date"].dt.year.unique()
        for year in sorted(years):
            # Create a year-level widget / Cria um widget de nível de ano
            year_widget = QWidget(dialog)
            year_layout = QVBoxLayout(year_widget)

            # Year-level checkbox (above all content for the year) / Checkbox
            # de nível de ano (acima de todo o conteúdo para o ano)
            year_checkbox = QCheckBox(f"Select All in {year}", dialog)
            year_checkbox.setChecked(
                True
                if self.recorte_datas is None
                else all(
                    str(date.date()) in self.recorte_datas
                    for date in self.df[self.df["date"].dt.year == year]["date"]
                )
            )
            year_checkbox.stateChanged.connect(
                lambda state, yr=year: self.toggle_year_checkboxes(yr, state)
            )
            scroll_layout.addWidget(year_checkbox)
            self.year_checkboxes[year] = year_checkbox

            # Indented content for the year / Conteúdo indentado para o ano
            year_content_widget = QWidget(dialog)
            year_content_layout = QVBoxLayout(year_content_widget)
            year_content_layout.setContentsMargins(
                20, 0, 0, 0
            )  # Add indentation for year content
            scroll_layout.addWidget(year_content_widget)

            # Add months under each year / Adiciona meses sob cada ano
            for (group_year, month), group in grouped:
                if group_year != year:
                    continue

                # Create a month-level widget / Cria um widget de nível de mês
                group_label = f"{group_year}-{month:02d}"
                month_widget = QWidget(dialog)
                month_layout = QVBoxLayout(month_widget)

                # Month toggle button / Botão de alternância do mês
                month_toggle_button = QToolButton(dialog)
                month_toggle_button.setText(f"▶ {group_label}")
                month_toggle_button.setCheckable(True)
                month_toggle_button.setChecked(True)
                month_toggle_button.setStyleSheet("text-align: left;")
                month_toggle_button.toggled.connect(
                    lambda checked, grp=month_widget, btn=month_toggle_button, lbl=group_label: self.toggle_group_visibility(
                        grp, btn, lbl
                    )
                )

                # Month-level checkbox / Checkbox de nível de mês
                group_checkbox = QCheckBox(f"Select All in {group_label}", dialog)
                group_checkbox.setChecked(
                    True
                    if self.recorte_datas is None
                    else all(
                        str(date.date()) in self.recorte_datas for date in group["date"]
                    )
                )
                group_checkbox.stateChanged.connect(
                    lambda state, grp=group_label: self.toggle_group_checkboxes(
                        grp, state
                    )
                )
                month_layout.addWidget(group_checkbox)
                self.group_checkboxes[group_label] = group_checkbox

                # Add individual checkboxes with further indentation / Adiciona
                # checkboxes individuais com mais indentação
                for date in group["date"]:
                    date_str = str(date.date())
                    checkbox = QCheckBox(date_str, dialog)
                    checkbox.setChecked(
                        True
                        if self.recorte_datas is None
                        else date_str in self.recorte_datas
                    )
                    month_layout.addWidget(checkbox)
                    checkbox.setContentsMargins(
                        20, 0, 0, 0
                    )  # Further indentation for dates
                    self.checkboxes.append((checkbox, group_label, group_year))

                # Add month layout to the year content layout / Adiciona o layout
                # do mês ao layout do conteúdo do ano
                year_content_layout.addWidget(month_toggle_button)
                year_content_layout.addWidget(month_widget)
                self.group_widgets[group_label] = month_widget

        scroll_content.setLayout(scroll_layout)
        scroll_area.setWidget(scroll_content)
        layout.addWidget(scroll_area)

        # Buttons / Botões
        # Use QDialogButtonBox.StandardButton for Qt6 compatibility
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel, dialog
        )
        button_layout = QHBoxLayout()
        apply_button = QPushButton("Apply", dialog)
        select_button = QPushButton("Select All", dialog)
        deselect_button = QPushButton("Deselect All", dialog)
        button_layout.addWidget(apply_button)
        button_layout.addWidget(select_button)
        button_layout.addWidget(deselect_button)
        layout.addLayout(button_layout)
        layout.addWidget(button_box)

        # Signal Connections / Conexões de Sinal
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        apply_button.clicked.connect(
            self.apply_changes
        )  # Apply without closing / Aplica sem fechar
        select_button.clicked.connect(self.select_all_checkboxes)
        deselect_button.clicked.connect(self.deselect_all_checkboxes)

        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.apply_changes()  # Ensure changes are applied before closing
        else:
            print("Time series dialog canceled. No changes made.")

    def apply_changes(self):
        """
        Apply changes to the selected dates without closing the dialog.

        This method updates the selected dates based on the checked checkboxes
        and adjusts the time series plot accordingly.
        """
        """
        Aplica as mudanças nas datas selecionadas sem fechar o diálogo.

        Este método atualiza as datas selecionadas com base nas checkboxes
        marcadas e ajusta o gráfico de séries temporais de acordo.
        """
        self.selected_dates = [
            cb.text() for cb, _, _ in self.checkboxes if cb.isChecked()
        ]
        self.recorte_datas = self.selected_dates
        print(f"Selected dates for time series (applied): {self.recorte_datas}")
        self.df_ajust()
        self.plot_timeseries()

        try:
            self.df_ajust_features()
            self.plot_timeseries_features()
            print("Feature info updated and ploted).")
        except:
            pass

        try:
            self.df_ajust_points()
            self.plot_timeseries_points()
            print("Points info updated and ploted).")
        except:
            pass

    def toggle_group_visibility(self, group_widget, toggle_button, group_label):
        """
        Toggle the visibility of a group widget.

        Args:
            group_widget (QWidget): The widget representing the group.
            toggle_button (QToolButton): The button used to toggle the
                visibility.
            group_label (str): The label of the group.
        """
        """
        Alterna a visibilidade de um widget de grupo.

        Args:
            group_widget (QWidget): O widget representando o grupo.
            toggle_button (QToolButton): O botão usado para alternar a
                visibilidade.
            group_label (str): O rótulo do grupo.
        """
        group_widget.setVisible(toggle_button.isChecked())
        toggle_button.setText(
            f"▶ {group_label}"
            if not toggle_button.isChecked()
            else f"▼ {group_label}"
        )

    def toggle_group_checkboxes(self, group_label, state):
        """
        Toggle all checkboxes in a month group.

        Args:
            group_label (str): The label of the group.
            state (int): The state of the checkbox (checked or unchecked).
        """
        """
        Alterna todas as checkboxes em um grupo de mês.

        Args:
            group_label (str): O rótulo do grupo.
            state (int): O estado da checkbox (marcado ou desmarcado).
        """
        for checkbox, group, _ in self.checkboxes:
            if group == group_label:
                checkbox.setChecked(state == Qt.Checked)

    def toggle_year_checkboxes(self, year, state):
        """
        Toggle all checkboxes in a year group.

        Args:
            year (int): The year to toggle.
            state (int): The state of the checkbox (checked or unchecked).
        """
        """
        Alterna todas as checkboxes em um grupo de ano.

        Args:
            year (int): O ano a ser alternado.
            state (int): O estado da checkbox (marcado ou desmarcado).
        """
        for checkbox, _, group_year in self.checkboxes:
            if group_year == year:
                checkbox.setChecked(state == Qt.Checked)
        for group_label, group_checkbox in self.group_checkboxes.items():
            if group_label.startswith(str(year)):
                group_checkbox.setChecked(state == Qt.Checked)

    def select_all_checkboxes(self):
        """Select all checkboxes."""
        """Seleciona todas as checkboxes."""
        for checkbox, _, _ in self.checkboxes:
            checkbox.setChecked(True)
        for group_checkbox in self.group_checkboxes.values():
            group_checkbox.setChecked(True)
        for year_checkbox in self.year_checkboxes.values():
            year_checkbox.setChecked(True)

    def deselect_all_checkboxes(self):
        """Deselect all checkboxes."""
        """Desmarca todas as checkboxes."""
        for checkbox, _, _ in self.checkboxes:
            checkbox.setChecked(False)
        for group_checkbox in self.group_checkboxes.values():
            group_checkbox.setChecked(False)
        for year_checkbox in self.year_checkboxes.values():
            year_checkbox.setChecked(False)

    def centralizar(self):
        """
        Centers the window on the screen without changing the screen the dialog
        is on.

        This method calculates the geometry of the window frame and moves it to
        the center of the available screen space on the current screen.
        """
        """
        Centraliza a janela na tela sem alterar a tela em que o diálogo está.

        Este método calcula a geometria do quadro da janela e a move para o
        centro do espaço de tela disponível na tela atual.
        """
        # 1. Get the current geometry of the window frame.
        qtRectangle = self.frameGeometry()
        # 2. Determine the center point of the available screen space on the
        # current screen.
        # screen = QDesktopWidget().screenNumber(self)
        # centerPoint = QDesktopWidget().availableGeometry(screen).center()
        # Replacement for QDesktopWidget using QApplication.primaryScreen()
        screen = QApplication.screenAt(self.frameGeometry().center())
        if screen is None:
            screen = QApplication.primaryScreen()
        centerPoint = screen.availableGeometry().center()
        # 3. Move the center of the window frame to the center point of the
        # screen.
        qtRectangle.moveCenter(centerPoint)
        # 4. Move the window to the new top-left position.
        self.move(qtRectangle.topLeft())

    def resizeEvent(self, size):
        # Remove size constraints first
        self.setMinimumSize(0, 0)
        self.setMaximumSize(16777215, 16777215)

        if size == "small":
            self.resize(765, 371)
            # Lock to small size - this prevents resizing
            self.setFixedSize(self.width(), self.height())
        elif size == "big":
            self.resize(1145, 620)
            # Lock to big size - this prevents resizing
            self.setFixedSize(self.width(), self.height())

    def on_tab_changed(self, index):
        # CRITICAL: Get the recursion guard flag safely.
        # If '_programmatic_tab_change' hasn't been set, default to False.
        _programmatic_tab_change = getattr(self, '_programmatic_tab_change', False)

        if _programmatic_tab_change:
            return

        # Helper function for safe programmatic tab changes
        # This also needs to set the attribute on 'self' if it's missing,
        # then manage it for the duration of the set.
        def _safe_set_current_index(target_index):
            # Ensure self.tabWidget exists before proceeding
            _tabWidget = getattr(self, 'tabWidget', None)
            if not _tabWidget:
                print("Warning: tabWidget not found, cannot set current index safely.")
                return False

            if _tabWidget.currentIndex() != target_index:
                # Set the flag on 'self'
                setattr(self, '_programmatic_tab_change', True)
                try:
                    _tabWidget.setCurrentIndex(target_index)
                finally:
                    # Reset the flag on 'self'
                    setattr(self, '_programmatic_tab_change', False)
                return True # Indicates tab was changed
            return False # Indicates no change was necessary or possible

        # --- Authentication Check ---
        # Get 'autentication' safely; if not set, default to False
        autentication = getattr(self, 'autentication', False)
        if not autentication:
            if index != 0:
                QMessageBox.warning(self, "Access Denied", "Please authenticate first!")
                if _safe_set_current_index(0):
                    return # Stop processing this event as tab was reverted

        # --- UI Resizing Logic ---
        # Get 'resizeEvent' safely
        _resizeEvent = getattr(self, 'resizeEvent', None)
        if index < 6:
            if _resizeEvent and callable(_resizeEvent):
                _resizeEvent("small")
            # else: print("Warning: resizeEvent method not found or not callable for 'small'.")
        elif index >= 6:
            if _resizeEvent and callable(_resizeEvent):
                _resizeEvent("big")
            # else: print("Warning: resizeEvent method not found or not callable for 'big'.")

            # Centralization logic
            _centralized = getattr(self, '_centralized', False)
            if not _centralized:
                _centralizar = getattr(self, 'centralizar', None)
                if _centralizar and callable(_centralizar):
                    _centralizar()
                    setattr(self, '_centralized', True) # Update the attribute on 'self'
                else:
                    print("Warning: centralizar method not found or not callable.")


        # --- Tab 1: Load Path Suggestion ---
        # Get 'path_suggestion_loaded' safely; if not set, default to False
        _path_suggestion_loaded = getattr(self, 'path_suggestion_loaded', False)
        if index == 1 and not _path_suggestion_loaded:
            try:
                _load_last_output_folder = getattr(self, 'load_last_output_folder', None)
                if _load_last_output_folder and callable(_load_last_output_folder):
                    _load_last_output_folder()
                    setattr(self, 'path_suggestion_loaded', True)
                else:
                    print("Warning: load_last_output_folder method not found or not callable.")
                    raise AttributeError("Method not found for fallback") # Force fallback if method doesn't exist
            except Exception as e:
                print(f"Error loading last output folder: {e}. Falling back to suggestion.")
                _load_path_sugestion = getattr(self, 'load_path_sugestion', None)
                if _load_path_sugestion and callable(_load_path_sugestion):
                    _load_path_sugestion()
                    setattr(self, 'path_suggestion_loaded', True) # Still set to True to prevent re-running on next visit
                else:
                    print("Warning: load_path_sugestion method not found or not callable.")

        # --- Tab 2: Load Vector Layers ---
        # Get 'vector_layers_loaded' safely; if not set, default to False
        _vector_layers_loaded = getattr(self, 'vector_layers_loaded', False)
        if index == 2 and not _vector_layers_loaded:
            try:
                _load_vector_layers = getattr(self, 'load_vector_layers', None)
                if _load_vector_layers and callable(_load_vector_layers):
                    _load_vector_layers()
                    _get_selected_layer_path = getattr(self, 'get_selected_layer_path', None)
                    if _get_selected_layer_path and callable(_get_selected_layer_path):
                        _get_selected_layer_path()
                    else:
                        print("Warning: get_selected_layer_path method not found or not callable.")
                    setattr(self, 'vector_layers_loaded', True)
                else:
                    print("Warning: load_vector_layers method not found or not callable.")
            except Exception as e:
                print(f"Error loading vector layers or getting path: {e}")
                # If it fails, keep vector_layers_loaded as False so it retries

        # --- Progression Checks (using QPushButton_next states) ---
        # Retrieve QPushButton objects safely. Assumes they might be assigned to 'self'
        # or you'd use self.findChild() in __init__ (preferred).
        # If they are not found in self.__dict__, getattr will return None.
        _QPushButton_next_4 = getattr(self, 'QPushButton_next_4', None)
        _QPushButton_next = getattr(self, 'QPushButton_next', None)

        if index > 1:
            if _QPushButton_next_4 and not _QPushButton_next_4.isEnabled():
                QMessageBox.warning(self, "Proceed Step-by-Step", "Please complete Step 2 before proceeding.")
                if _safe_set_current_index(1):
                    return

        if index > 2:
            if _QPushButton_next and not _QPushButton_next.isEnabled():
                QMessageBox.warning(self, "Proceed Step-by-Step", "Please complete Step 3 before proceeding.")
                if _safe_set_current_index(2):
                    _resizeEvent("small")
                    return


        _drawing = getattr(self, 'drawing', None)
        if index != 2:
            if _drawing:
                try:
                    _drawing.setChecked(False)
                except Exception as e:
                    print(f"Error unchecking coordinate capture checkbox: {e}")
            else:
                print("Warning: checkBox_captureCoordinates not found or accessible.")

    def next_clicked(self):
        self.tabWidget.setCurrentIndex(
            (self.tabWidget.currentIndex() + 1) % self.tabWidget.count()
        )

    def back_clicked(self):
        self.tabWidget.setCurrentIndex(
            (self.tabWidget.currentIndex() - 1) % self.tabWidget.count()
        )


    def load_path_sugestion(self):
        """
        Load the path suggestion based on the user's operating system.
        """
        """
        Carrega a sugestão de caminho com base no sistema operacional do
        usuário.
        """
        system = platform.system()
        if system == "Windows":
            self.output_folder = os.path.join(os.environ["USERPROFILE"], "Downloads")
        elif system == "Linux":
            self.output_folder = os.path.join(os.environ["HOME"], "Downloads")
        elif system == "Darwin":  # MacOS
            self.output_folder = os.path.join(os.environ["HOME"], "Downloads")

        # Pre-configure with a suggested directory / Pré-configura com um
        # diretório sugerido
        self.mQgsFileWidget.setFilePath(self.output_folder)

    def pop_warning(self, aviso):
        QApplication.restoreOverrideCursor()
        msg = QMessageBox(self)
        msg.setWindowTitle("Warning!")

        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setText(aviso)
        msg.setStandardButtons(QMessageBox.StandardButton.Ok)
        msg.button(QMessageBox.StandardButton.Ok).setText("OK")
        msg.setStyleSheet("font-size: 10pt;")
        msg.exec()

    def update_vector_clicked(self):
        self.load_vector_layers()
        self.get_selected_layer_path()
        self.load_vector_function()

    def load_vector_layers(self):
        # Get all layers in the current QGIS project / Obtém todas as camadas
        # no projeto QGIS atual
        layers = list(QgsProject.instance().mapLayers().values())

        # Filter polygon and multipolygon vector layers / Filtra camadas
        # vetoriais de polígono e multipolígono
        vector_layers = [
            layer
            for layer in layers
            if layer.type() == QgsMapLayer.VectorLayer
            and layer.geometryType() == QgsWkbTypes.PolygonGeometry
        ]

        # Get current layer names / Obtém os nomes das camadas atuais
        current_layer_names = set(
            self.vector_layer_combobox.itemText(i)
            for i in range(self.vector_layer_combobox.count())
        )

        # Clear the combobox and the dictionary / Limpa a combobox e o
        # dicionário
        self.vector_layer_combobox.clear()
        self.vector_layer_ids = {}

        # Find the new layer while populating the combobox / Encontra a nova
        # camada enquanto popula a combobox
        new_layer_name = None
        for layer in vector_layers:
            layer_name = layer.name()
            self.vector_layer_combobox.addItem(layer_name)
            self.vector_layer_ids[layer_name] = layer.id()

            # If this layer wasn't in the previous list, it's new / Se esta
            # camada não estava na lista anterior, é nova
            if layer_name not in current_layer_names:
                new_layer_name = layer_name

        # Update the second combobox / Atualiza a segunda combobox
        self.vector_layer_combobox_2.clear()
        self.vector_layer_combobox_2.addItems(
            self.vector_layer_combobox.itemText(i)
            for i in range(self.vector_layer_combobox.count())
        )
        self.vector_layer_combobox_2.setCurrentIndex(
            self.vector_layer_combobox.currentIndex()
        )

        # If we found a new layer, select it / Se encontramos uma nova camada,
        # selecione-a
        if new_layer_name:
            index = self.vector_layer_combobox.findText(new_layer_name)
            self.vector_layer_combobox.setCurrentIndex(index)

        if self.vector_layer_combobox.count() == 0:
            self.aoi = None
            self.tabWidget.setCurrentIndex(2)
            
            self.pop_warning("Nenhuma camada vetorial encontrada no projeto.")

    def get_selected_layer_path(self):
        """
        Retrieves the path of the currently selected layer in the combobox and
        triggers further processing.
        """
        """
        Recupera o caminho da camada atualmente selecionada na combobox e
        aciona o processamento adicional.
        """
        # Get the currently selected layer name from the combobox / Obtém o nome
        # da camada atualmente selecionada da combobox
        layer_name = (
            self.vector_layer_combobox.currentText().strip()
        )  # Remove whitespace
        if layer_name == "":
            print("No layer selected.")
            self.aoi_area.setText("Total Area:")
            self.QPushButton_next.setEnabled(False)
            self.QPushButton_skip.setEnabled(False)
            return None
        print(f"Layer name from combobox: '{layer_name}'")  # Debug
        self.zoom_to_layer(layer_name)

        # Get the corresponding layer ID / Obtém o ID da camada
        # correspondente
        layer_id = self.vector_layer_ids.get(layer_name)
        print(f"Layer ID from vector_layer_ids: {layer_id}")  # Debug

        if layer_id is None:
            print(
                f"Error: Layer ID is None for layer name '{layer_name}'.  Check vector_layer_ids."
            )
            print(
                f"Contents of vector_layer_ids: {self.vector_layer_ids}"
            )  # Debug
            return None

        # Get the layer using its ID / Obtém a camada usando seu ID
        layer = QgsProject.instance().mapLayer(layer_id)
        if layer:
            print(
                f"Layer found: {layer.name()}, ID: {layer_id}"
            )  # Debug: Confirm layer is found
            self.selected_aio_layer_path = (
                layer.dataProvider().dataSourceUri().split("|")[0]
            )
            print(
                f"Selected layer path: {self.selected_aio_layer_path}"
            )  # Debug: Show selected layer path

            # Trigger the processing function / Aciona a função de
            # processamento
            self.aoi = self.load_vector_function()
            area = self.find_area()
            if area > 100:
                self.QPushButton_next.setEnabled(False)
                self.QPushButton_skip.setEnabled(False)
                self.loadtimeseries.setEnabled(False)
                self.pop_warning("Área muito grande ({:.2f} km²). O limite é de 100 km².".format(area))
                self.aio = None
                #self.on_tab_changed(2)
                return None

            self.QPushButton_next.setEnabled(True)
            self.QPushButton_skip.setEnabled(True)
            self.loadtimeseries.setEnabled(True)

            return None
        else:
            print(
                f"Layer '{layer_name}' with ID '{layer_id}' not found in the project."
            )
            return None
        
    def apply_buffer(self, aoi):
        """Applies a buffer to the AOI geometry."""
        buffer_distance = self.horizontalSlider_buffer.value()
        if buffer_distance != 0:
            print(f"Buffer distance: {buffer_distance} meters")
            aoi = aoi.map(lambda feature: feature.buffer(buffer_distance))
            #self.aoi = aoi
            return aoi
        else:
            print("No buffer applied")
            return aoi

    def calculate_index_with_mean(self, image, index_name, aoi):
        """Calculates the mean value for the specified index over the AOI."""
        index_image = self.calculate_vegetation_index(image, index_name)
        mean_index = (
            index_image.reduceRegion(
                reducer=ee.Reducer.mean(), geometry=aoi, scale=10, bestEffort=True
            ).get("index")
        )
        return image.set({"mean_index": mean_index})

    def zoom_to_layer(self, layer_name, margin_ratio=0.3):
        """
        Zoom to the specified layer with an optional margin.

        :param layer_name: Name of the layer to zoom to.
        :param margin_ratio: Fraction of the extent to add as margin (default
            is 0.1, or 10%).
        """
        """
        Amplia para a camada especificada com uma margem opcional.

        :param layer_name: Nome da camada para ampliar.
        :param margin_ratio: Fração da extensão para adicionar como margem
            (o padrão é 0,1 ou 10%).
        """
        project = QgsProject.instance()
        layers = project.mapLayersByName(
            layer_name
        )  # Get layers matching the name

        if not layers:
            print(f"Layer '{layer_name}' not found.")
            return

        layer = layers[0]  # Use the first matching layer
        iface = qgis.utils.iface  # Access the QGIS interface
        canvas = iface.mapCanvas()  # Get the active map canvas

        # Ensure the canvas CRS matches the layer CRS
        canvas.setDestinationCrs(layer.crs())

        # Get the layer's extent and add a margin
        layer_extent = layer.extent()
        x_margin = layer_extent.width() * margin_ratio
        y_margin = layer_extent.height() * margin_ratio

        expanded_extent = QgsRectangle(
            layer_extent.xMinimum() - x_margin,
            layer_extent.yMinimum() - y_margin,
            layer_extent.xMaximum() + x_margin,
            layer_extent.yMaximum() + y_margin,
        )

        # Set the expanded extent to the canvas
        canvas.setExtent(expanded_extent)
        canvas.refresh()

        print(f"Zoomed to layer extent with margin: {expanded_extent.toString()}")

    def get_subdirectory_filename(self, base_name, temporary=False):
        """
        Creates a unique layer name with incrementing number and 
        matching subdirectory, then returns the unique filename path.
        """
        if temporary:
            base_output_folder = tempfile.gettempdir()
        else:
            base_output_folder = self.output_folder
        
        # Find a unique layer name with incrementing number
        counter = 1
        layer_name = f"{base_name}{counter}"
        subdirectory_path = os.path.join(base_output_folder, layer_name)
        
        # Keep incrementing until we find an unused name
        while os.path.exists(subdirectory_path):
            counter += 1
            layer_name = f"{base_name}{counter}"
            subdirectory_path = os.path.join(base_output_folder, layer_name)
        
        # Create the directory
        os.makedirs(subdirectory_path)
        
        # Create the filename with the same base name
        file_name = f"{layer_name}.shp"
        file_path = os.path.join(subdirectory_path, file_name)
        
        print(f"Unique layer name: {layer_name}")
        print(f"Unique filename: {file_path}")
        
        return file_path, layer_name

    def get_unique_filename(self, base_file_name, temporary=False):
        name, extension = os.path.splitext(base_file_name)
        if temporary:
            output_folder = tempfile.gettempdir()  # Get system's temp directory
            output_file = os.path.join(output_folder, base_file_name)
        else:
            output_file = os.path.join(self.output_folder, base_file_name)
            output_folder = self.output_folder
        counter = 1

        while os.path.exists(output_file):
            output_file = os.path.join(
                output_folder, f"{name}_{counter}{extension}"
            )
            counter += 1

        print(f"Unique filename: {output_file}")
        return output_file

    def sentinel2_selected_dates_update(self):
        Date_list_selection = (
            [
                date.strftime("%Y-%m-%d")
                for date in pd.to_datetime(self.df_aux["date"]).tolist()
            ]
            if "date" in self.df_aux.columns
            else []
        )
        print(f"Selected dates for time series: {Date_list_selection}")

        print("Final number of images before:", self.sentinel2.size().getInfo())
        dates_in_collection = self.sentinel2.aggregate_array("date").getInfo()
        print(f"Dates in the collection: {dates_in_collection}")
        print(f"Selected dates (timestamps): {Date_list_selection}")

        # Filtra a coleção Sentinel-2 pelas datas selecionadas
        sentinel2_selected_dates = self.sentinel2.filter(
            ee.Filter.inList("date", ee.List(Date_list_selection))
        )
        print(
            "Final number of images after:", sentinel2_selected_dates.size().getInfo()
        )

        self.sentinel2_selected_dates = sentinel2_selected_dates

    def on_file_changed(self, file_path):
        """Slot called when the selected file changes."""
        """Slot chamado quando o arquivo selecionado muda."""
        
        if self.mQgsFileWidget.filePath():
            print(f"File selected: {file_path}")
            self.output_folder = file_path
            self.folder_set = True
            self.QPushButton_next_4.setEnabled(True)
            
            # Save the selected file path to QGIS settings for persistence
            QSettings().setValue("aglgis_plugin/last_output_folder", file_path)
            print(f"Last output folder saved: {file_path}")
        else:
            print("No file selected.")
            self.folder_set = False
            self.QPushButton_next_4.setEnabled(False)

    def load_last_output_folder(self):
        """Loads the last selected output folder from QGIS settings."""
        """Carrega a última pasta de saída selecionada das configurações do QGIS."""
        
        last_folder = QSettings().value("aglgis_plugin/last_output_folder", "")
        if last_folder:
            self.mQgsFileWidget.setFilePath(last_folder)
            self.output_folder = last_folder
            self.folder_set = True
            self.QPushButton_next_4.setEnabled(True)
            print(f"Last output folder loaded: {last_folder}")
        else:
            print("No previously selected output folder found.")

    def load_vector_function(self, shapefile_path=None):
        """
        Loads the vector layer from the selected file path, reprojects it to
        EPSG:4326, dissolves multiple features if necessary, and converts it
        into an Earth Engine FeatureCollection representing the AOI.
        """
        """
        Carrega a camada vetorial do caminho do arquivo selecionado, a
        reprojeta para EPSG:4326, dissolve várias feições, se necessário, e a
        converte em um Earth Engine FeatureCollection representando a AOI.
        """
        if shapefile_path is None:
            shapefile_path = self.selected_aio_layer_path

        try:
            # Load the shapefile, handling both .zip archives and regular files.
            if shapefile_path.endswith(".zip"):
                with zipfile.ZipFile(shapefile_path, "r") as zip_ref:
                    shapefile_found = False
                    for file in zip_ref.namelist():
                        if file.endswith(".shp"):
                            shapefile_found = True
                            shapefile_within_zip = file
                            break
                    if not shapefile_found:
                        print("No .shp file found inside the zip archive.")
                        return

                    # Read shapefile directly from the zip archive.
                    aoi = gpd.read_file(
                        f"zip://{shapefile_path}/{shapefile_within_zip}"
                    )
            else:
                aoi = gpd.read_file(shapefile_path)

            # Reproject the GeoDataFrame to EPSG:4326 to ensure correct
            # coordinates for Earth Engine.
            aoi = aoi.to_crs(epsg=4326)

            if aoi.empty:
                print("The shapefile does not contain any geometries.")
                return

            # Dissolve multiple features into a single geometry if necessary.
            if len(aoi) > 1:
                aoi = aoi.dissolve()

            # Extract the first geometry.
            geometry = aoi.geometry.iloc[0]

            # Convert the geometry to GeoJSON format.
            geojson = geometry.__geo_interface__

            # Remove any third dimension from the coordinates.
            if geojson["type"] == "Polygon":
                geojson["coordinates"] = [
                    list(map(lambda coord: coord[:2], ring)) for ring in geojson["coordinates"]
                ]
            elif geojson["type"] == "MultiPolygon":
                geojson["coordinates"] = [
                    [list(map(lambda coord: coord[:2], ring)) for ring in polygon]
                    for polygon in geojson["coordinates"]
                ]

            # Create an Earth Engine geometry object.
            ee_geometry = ee.Geometry(geojson)
            feature = ee.Feature(ee_geometry)
            aoi = ee.FeatureCollection([feature])

            print("AOI defined successfully.")
            self.QPushButton_next.setEnabled(True)
            self.QPushButton_skip.setEnabled(True)
            self.aio_set = True
            self.vector_layer_combobox_2.setCurrentIndex(
                self.vector_layer_combobox.currentIndex()
            )

            self.aoi_ckecked = True
            self.aoi_ckecked_function()

            return aoi

        except Exception as e:
            print(f"Error in load_vector_function: {e}")
            return

    def find_centroid(self):
        centroid = self.aoi.geometry().centroid()
        self.lat = centroid.getInfo().get("coordinates")[1]
        self.lon = centroid.getInfo().get("coordinates")[0]
        print(f"{round(self.lat,4)},{round(self.lon,4)}")
        area = (
            self.aoi.geometry().area().getInfo() / 1e6
        )  # Convert from square meters to square kilometers
        print(f"Area: {area:.2f} km²")
        if area >= 100:
            self.aoi = None
            self.aoi_ckecked = False
            self.aoi_ckecked_function()
        return area

    def find_area(self):
        try:
            area_km2 = (
                self.aoi.geometry().area().getInfo() / 1e6
            )  # Convert from square meters to square kilometers
            area_ha = area_km2 * 100  # Convert from square kilometers to hectares
            print(f"Area: {area_km2:.2f} km² ({area_ha:.2f} ha)")
            self.aoi_area.setText(
                f"Total Area: {area_km2:.2f} km² ({area_ha:.2f} hectares)"
            )
            return area_km2
        except Exception as e:
            print(f"Error in find_area: {e}")
            self.aoi_area.setText(f"Total Area:")
            return 0

    def aoi_ckecked_function(self):
        if self.aoi_ckecked and self.folder_set:
            self.QPushButton_next.setEnabled(True)
            self.QPushButton_skip.setEnabled(True)
        else:
            self.QPushButton_next.setEnabled(False)
            self.QPushButton_skip.setEnabled(False)

    def resetting(self):
        self.recorte_datas = None
        self.aoi = self.load_vector_function()
        self.inicio = self.incioedit.date().toString("yyyy-MM-dd")
        self.final = self.finaledit.date().toString("yyyy-MM-dd")
        self.df_aux = None

    def loadtimeseries_clicked(self):
        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
        try:
            self.resetting()
            self.plot_timeseries()
        except Exception as e:
            print(f"Error during timeseries loading: {e}")

        QApplication.restoreOverrideCursor()

    def df_ajust(self):
        """Adjusts the main DataFrame based on the selected dates."""
        """Ajusta o DataFrame principal com base nas datas selecionadas."""
        df = self.df.copy()
        if self.recorte_datas:
            # Ensure both sides are strings for comparison
            df = df[df["date"].astype(str).isin([str(d) for d in self.recorte_datas])]
            self.df_aux = df.copy()
        else:
            self.df_aux = df.copy()

    def plot_timeseries(self):
        print("plot1 started")

    def open_browser(self):
        """Opens the plot in a web browser."""
        """Abre o gráfico em um navegador da web."""
        self.fig.show()

    def load_dates(self):
        """Loads the unique dates from the DataFrame into the date selection
        combobox."""
        """Carrega as datas exclusivas do DataFrame na combobox de seleção de
        data."""
        datas = self.df.date.unique().astype(str).tolist()
        self.dataunica.clear()
        self.dataunica.addItems(datas)
        self.dataunica.setCurrentIndex(self.dataunica.count() - 1)
